[MODE: RESEARCH]
基于代码库现状的关键观察：

- 代理转发：`src/app/api/[...path]/route.ts` 统一处理所有方法到 `proxy(req)`，从 `process.env.API_BASE_URL` 构造上游地址；当环境变量为空直接返回 500。已删除原始 `host`，其余请求头保持透传；仍缺少 `x-forwarded-host/proto/for` 等治理头。参考定位：

```5:13:c:\Users\lingh\Desktop\test-front\test-ap\src\app\api[...path]\route.ts
const base = (process.env.API_BASE_URL || '').replace(/\/$/, '')
if (!base) return NextResponse.json({...}, { status: 500 })
```

- 鉴权策略：仅对以 `/api/store` 开头及等于 `/api/auth/logout` 的路径强制 `Authorization`，登录接口 `/api/auth/login` 不做令牌校验（符合预期）。
- HTTP 客户端：`src/utils/http.ts` 的 `resolveBaseURL()` 当前返回空字符串，使 `axios.baseURL=''`，前端以相对路径命中同源代理；但未显式固定为 `'/api'`。参考定位：

```9:17:c:\Users\lingh\Desktop\test-front\test-ap\src\utils\http.ts
function resolveBaseURL(): string { return '' }
```

- 请求拦截器：默认从本地读取令牌并附加 `Authorization: Bearer <token>`，所有请求均注入；这会让 `/api/auth/login` 在已登录设备上也带令牌，部分后端可能因此拒绝。
- 响应拦截器：已区分 `401/403` 并在 `401` 清理令牌；未统一打印 `x-proxy-upstream` 等观测信息。
- 登录流程：`src/utils/api.ts` 的 `telegramLogin()` 仅在 Telegram 环境且存在 `rawInitData` 时请求 `POST /api/auth/login`，请求体 `{ initData }`；成功后持久化令牌；失败返回标准错误。
- 触发入口：`src/app/home/page.tsx` 在首次渲染的 `useEffect` 自动尝试登录，非 Telegram 环境或无 `rawInitData` 则跳过。
- 环境变量读取：代码库仅在代理路由读取 `process.env.API_BASE_URL`；当前工作目录为 `test-ap`，用户陈述的 `.env` 路径位于另一项目 `nova_explorer_bot_frontend`，存在路径不一致，需要在本项目根配置（建议 `.env.local`）。

疑问点（无需阻塞执行，计划内将兼容）：

- 后端是否要求在登录接口显式禁止带 `Authorization`？若是，则拦截器需豁免 `/api/auth/login` 注入令牌。
- 后端是否需要自定义头 `X-Telegram-Init-Data` 参与校验？如需，将由前端可控开关附加并由代理透传。

[MODE: INNOVATE]
可能方案与取舍：

- 头治理加强：在代理层主动补齐 `x-forwarded-host/x-forwarded-proto/x-forwarded-for/x-real-ip`，删除 `host`，最小化头透传，提升后端对来源、协议与真实客户端的识别能力；兼顾安全与兼容。
- 登录无令牌：在前端请求拦截器为 `/api/auth/login` 明确不注入 `Authorization`，降低后端误判风险；其余业务接口维持令牌注入与代理层校验。
- 观测增强：失败时在响应拦截器打印 `status/x-proxy-upstream/message`，帮助快速定位问题源头（签名、白名单、来源等）；代理层所有响应附带观测头，便于链路追踪。
- 基础地址统一：`resolveBaseURL()` 固定返回 `'/api'`，强制前端统一走同源代理以规避 CORS 与头域差异。
- 登录契约明确：请求体仅 `{ initData }`；如需自定义头，由前端附加并由代理透传；避免在服务端日志打印完整 `initData`，仅保留必要观测信息。

[MODE: PLAN]
变更规格（不含示例代码）：

1) 环境与基础配置

- 文件：项目根 `.env`
- 变量：`API_BASE_URL=https://<your-upstream-domain>`
- 运行：Next 通过 `process.env.API_BASE_URL` 读取（无需额外代码）。

2) 代理路由改造

- 文件：`src/app/api/[...path]/route.ts`
- 头治理：
  - 删除上游请求中的 `host`。
  - 新增并透传：
    - `x-forwarded-host`: 来自 `req.headers.get('host')`
    - `x-forwarded-proto`: 从 `new URL(req.url).protocol` 推断 `http/https`
    - `x-forwarded-for`: 若 `req.headers` 已含则保留，否则不强填；同理 `x-real-ip`
  - 保持最小必要头透传，避免浏览器无关 Cookie 发送。
- 鉴权策略：保持仅对 `/api/store*` 与 `/api/auth/logout` 强制 `Authorization` 检查；`/api/auth/login` 不校验令牌。
- 响应观测：所有响应统一附带 `x-proxy-upstream` 与 `x-proxy-runtime=nodejs`；JSON 透传，非 JSON 原样文本。

3) HTTP 客户端拦截器

- 文件：`src/utils/http.ts`
- 基础地址：`resolveBaseURL()` 返回 `'/api'`，`axios.baseURL` 统一同源代理。
- 请求拦截器：
  - 对 `GET` 继续附加 `_t` 时间戳。
  - 从本地读取令牌并注入 `Authorization`，但当 `url` 匹配 `'/api/auth/login'` 时不注入（豁免）。
- 响应拦截器：
  - 统一标准化结构映射：若返回含 `{ code, message, data, success, timestamp }`，则直接按该结构输出；否则维持原始 `data`。
  - 错误链路：
    - `401`：清理令牌并提示重新登录。
    - `403`：提示无权限但保留令牌。
  - 观测日志：在错误场景打印 `status`、`headers['x-proxy-upstream']`（如存在）、`message`。

4) 登录流程与可选自定义头

- 文件：`src/utils/api.ts`
- `telegramLogin()`：
  - 仅在 Telegram 环境且存在 `rawInitData` 时触发。
  - 请求体固定为 `{ initData }`。
  - 若后端要求，启用可控开关在请求头附加 `X-Telegram-Init-Data: <initData>`，代理保持透传。
  - 成功持久化 `accessToken/refreshToken/userInfo`；失败返回标准错误并记录时间戳与必要观测日志。

5) 页面触发验证

- 文件：`src/app/home/page.tsx`
- 首次渲染自动触发登录逻辑维持不变；在失败分支补充更明确的控制台日志，包含 `status` 与上游地址（通过响应头）。

6) 测试与验证

- 单元验证：
  - `http` 响应拦截器对 `401/403` 的分支行为与文案。
  - `telegramLogin()` 在有/无 `rawInitData` 两种分支的返回结构。
- 集成验证：
  - `.env.local` 正确配置后，访问 `home` 页自动登录；成功应返回用户数据并持久化；失败打印 `status/x-proxy-upstream/message`。
  - 代理层头治理：在后端或抓包确认 `x-forwarded-*` 头到位。
- 灰度策略：先在开发环境启用；如异常，回退 `resolveBaseURL()` 或关闭自定义头透传。

Implementation Checklist:

1. 在项目根 `.env.local` 配置 `API_BASE_URL` 指向正确后端域名。
2. 将 `resolveBaseURL()` 固定为 `'/api'`，统一前端请求经由代理。
3. 在代理路由补充 `x-forwarded-host/proto/for/real-ip` 头并删除 `host`。
4. 保持鉴权仅作用于业务接口（`/api/store*`、`/api/auth/logout`），登录接口不校验令牌。
5. 登录请求体固定 `{ initData }`，按需开启并透传 `X-Telegram-Init-Data`。
6. 优化 `http` 响应拦截器：区分 `401/403` 与业务错误，统一返回结构并增强日志。
7. 在登录失败时打印 `status/x-proxy-upstream/message`，辅助定位问题。
8. 与后端确认来源白名单配置，确保代理后的 `Origin/Host` 可被接受。
9. 在 `src/app/home/page.tsx` 验证登录链路，确认成功与失败分支均符合预期。
10. 回归测试并完成灰度，准备推广到生产。
